/*
 * generated by Xtext 2.21.0
 */
package org.xtext.assingment2.generator

import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.assingment2.mathinterpreter.DefineExpr
import org.xtext.assingment2.mathinterpreter.Divide
import org.xtext.assingment2.mathinterpreter.Function
import org.xtext.assingment2.mathinterpreter.MDExpression
import org.xtext.assingment2.mathinterpreter.MathExpression
import org.xtext.assingment2.mathinterpreter.Minus
import org.xtext.assingment2.mathinterpreter.Model
import org.xtext.assingment2.mathinterpreter.Multiply
import org.xtext.assingment2.mathinterpreter.Negative
import org.xtext.assingment2.mathinterpreter.Number
import org.xtext.assingment2.mathinterpreter.PMExpression
import org.xtext.assingment2.mathinterpreter.Plus
import org.xtext.assingment2.mathinterpreter.Positive
import org.xtext.assingment2.mathinterpreter.Primary
import org.xtext.assingment2.mathinterpreter.Variable
import org.xtext.assingment2.mathinterpreter.VariableName
import java.util.HashMap
import org.xtext.assingment2.mathinterpreter.PMParenthesis
import org.xtext.assingment2.mathinterpreter.DefParenthesis
import org.xtext.assingment2.mathinterpreter.VariableDefinition

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathinterpreterGenerator extends AbstractGenerator {
	
	HashMap<String, Integer> global;
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		global = new HashMap<String, Integer>()
		resource.allContents.filter(Model).next.mathexpression.forEach[compute]
	}
	
	def String compute(MathExpression math) { 
		switch (math){
			VariableDefinition: computeDefinition(math)
			default: showDialog("Interpreted: "+math.display+" as "+computeExpression(math).toString)
		}
	}
	
	def String computeResult(MathExpression math){
		switch (math){
			VariableDefinition: math.display
			default: computeExpression(math).toString
		}
	}
	
	def String showDialog(String message){
		System.out.println(message)
		JOptionPane.showMessageDialog(null, message, "Math Language", JOptionPane.INFORMATION_MESSAGE)
		message
	}
	
	def dispatch int computeExpression(Function func){
		val result = computePrimary(func.expression, null)
		result
	}
	
	def dispatch int computeExpression(DefineExpr defi){
		val result = defi.computeVariables(new HashMap<String, Integer>())
		result
	}
	
	def String computeDefinition(VariableDefinition vardef){
		vardef.variable.computeVariable(global)
		showDialog(vardef.display)
	}
	
	def int computeVariables(DefineExpr defi, HashMap<String, Integer> vars){
		defi.variables.forEach[computeVariable(vars)]
		computePrimary(defi.expression, vars)
	}
	
	def void computeVariable(Variable nvar, HashMap<String, Integer> vars){
		val res = computePrimary(nvar.expression, vars)
		vars.put(nvar.name, res)
	}

	// This definition takes care of adding and subtracting
	def dispatch int computePrimary(PMExpression exp, HashMap<String, Integer> vars) {
		val left = computePrimary(exp.left, vars)
		switch exp.operator {
			Plus: left+computePrimary(exp.right, vars)
			default: left-computePrimary(exp.right, vars) 
		}
	}
	
	// This definition takes care of multiplying and dividing
	def dispatch int computePrimary(MDExpression exp, HashMap<String, Integer> vars){
		val left = computePrimary(exp.left, vars)
		switch exp.operator {
			Multiply: left*computePrimary(exp.right, vars)
			default: left/computePrimary(exp.right, vars)
		}
	}
	
	def dispatch int computePrimary(Primary factor, HashMap<String, Integer> vars) { 
		switch(factor){
			Number: factor.getValue
			DefParenthesis: factor.computeParenthesis(vars)
			VariableName: factor.variableValue(vars)
			Variable: computePrimary(factor.expression, vars)
			PMParenthesis: factor.expression.computePrimary(vars)
		}
	}
	
	def dispatch int getValue(Negative negative) {-negative.value}
	def dispatch int getValue(Positive positive) { positive.value}
	
	def int variableValue(VariableName name, HashMap<String, Integer> vars){
		if (vars === null){
			global.get(name.name)
		} else {
			vars.get(name.name)		
		}
	}
	
	def dispatch int computeParenthesis(PMExpression exp, HashMap<String, Integer> vars){
		exp.computePrimary(vars)
	}
	def dispatch int computeParenthesis(DefineExpr exp, HashMap<String, Integer> vars){
		exp.computeExpression
	}
	
	// highlevel display
	def dispatch String display(MathExpression math) {
		switch (math){
			VariableDefinition: '''«math.variable.display»'''
			Function:'''«math.expression.display»'''
			DefineExpr:'''«math.expression.display»'''
		}
	}
	def dispatch String display(PMExpression exp) {
		'''(«exp.left.display»«exp.operator?.display»«exp.right?.display»)'''
	}
	def dispatch String display(MDExpression exp) {
		'''(«exp.left.display»«exp.operator?.display»«exp.right?.display»)'''
	} 
	def dispatch String display(DefineExpr exp) {
		'''(«exp.expression.display»)'''
	}
	def dispatch String display(VariableDefinition vardef){
		'''defined '«vardef.variable.display»' as «vardef.variable.expression.display»'''
	}
	def dispatch String display(Plus plus){"+"}
	def dispatch String display(Minus minus){"-"}
	def dispatch String display(Divide divide){"/"}
	def dispatch String display(Multiply multiply){"*"}
	
	def dispatch String display(Primary primary){'''«primary.display»'''}
	def dispatch String display(Number number){'''«number.display»'''}
	def dispatch String display(Positive positive){ '''«positive.value»'''	}
	def dispatch String display(Negative negative){ '''«-negative.value»'''	}
	def dispatch String display(VariableName varname){'''«varname.name»'''}
	def dispatch String display(Variable variable) {'''«variable.name»'''}
	
	def dispatch String display(PMParenthesis pmpar){'''«pmpar.expression.display»'''}
	def dispatch String display(DefParenthesis defpar){'''«defpar.display»'''}
}
